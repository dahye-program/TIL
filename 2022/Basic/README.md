# Basic

## RESTful API

> 월드 와이드 웹(World Wide Web a.k.a WWW)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴

`REST`란, REpresentational State Transfer 의 약자이다. 여기에 ~ful 이라는 형용사형 어미를 붙여 ~한 API 라는 표현으로 사용된다. 즉, REST 의 기본 원칙을 성실히 지킨 서비스 디자인은 'RESTful'하다라고 표현할 수 있다.

`REST`가 디자인 패턴이다, 아키텍처다 많은 이야기가 존재하는데, 하나의 아키텍처로 볼 수 있다. 좀 더 정확한 표현으로 말하자면, REST 는 `Resource Oriented Architecture` 이다. API 설계의 중심에 자원(Resource)이 있고 HTTP Method 를 통해 자원을 처리하도록 설계하는 것이다.

### REST 6가지 원칙

- Uniform Interface
- Stateless
- Caching
- Client-Server
- Hierarchical system
- Code on demand

### RESTful 하게 API를 디자인한다는 것은 무엇을 의미하는지?

1. **리소스** 와 **행위** 를 명시적이고 직관적으로 분리한다.
   - 리소스는 `URI`로 표현되는데 리소스가 가리키는 것은 `명사`로 표현되어야 한다.
   - 행위는 `HTTP Method`로 표현하고, `GET(조회)`, `POST(생성)`, `PUT(기존 entity 전체 수정)`, `PATCH(기존 entity 일부 수정)`, `DELETE(삭제)`을 분명한 목적으로 사용한다.
2. Message 는 Header 와 Body 를 명확하게 분리해서 사용한다.
   - Entity 에 대한 내용은 body 에 담는다.
   - 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, 응답받고자 하는 MIME 타입 등은 header 에 담는다.
   - header 와 body 는 http header 와 http body 로 나눌 수도 있고, http body 에 들어가는 json 구조로 분리할 수도 있다.
3. API 버전을 관리한다.
   - 환경은 항상 변하기 때문에 API 의 signature 가 변경될 수도 있음에 유의하자.
   - 특정 API 를 변경할 때는 반드시 하위호환성을 보장해야 한다.
4. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.
   - 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 json 으로 보내든, 둘 다 form-data 형식으로 보내든 하나로 통일한다.
   - 다른 말로 표현하자면 URI 가 플랫폼 중립적이어야 한다.

### 장점

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

### 단점

1. 사용할 수 있는 메소드가 4 가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.

## TDD(Test-Driven Development)

- 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스
- 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성
- 일단 테스트 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거치는 것
- 테스트가 코드 작성을 주도하는 개발 방식

### Add a test

- 새로운 기능을 추가하기 전 테스트 작성
- 테스트를 작성하기 위해서는 해당 기능의 요구사항과 명세를 분명히 이해하고 있어야 함

  ⇒ 사용자 케이스, 사용자 스토리

  ⇒ 개발자가 코드를 작성하기 전 요구사항에 집중할 수 있게 됨

  **TDD의 장점**

### Run all tests and see if new one fails

- 새로운 기능을 추가할 때 테스트 코드 작성
- 새로운 기능이 제대로 작동함과 동시에 기존 기능들이 잘 작동하는지 테스트
- 어떤 새로운 기능을 추가하면 잘 작동하던 기능이 제대로 작동하지 않는 경우 존재

### Refactor code

- 좋은 코드를 작성하기 위해 ...
  - 가독성을 위한 coding convention
  - 네이밍 규칙 적용한 메소드명, 변수명, 클래스명의 일관성
  - 확장성 고려
  - 비즈니스 로직에 대한 고려
  - 예외처리
- 코드량이 방대해지며 리팩토링을 필요로함 ⇒ 테스트 코드가 중심을 잡아줄 수 있음
- 함수를 여러 함수로 나누는 과정에서 해당 기능이 오작동을 일으킬 수 있지만 간단히 테스트를 돌려봄으로써 리팩토링 진행
- 결과적으로 리팩토링 속도도 빨라지고 코드의 퀄리티도 향상됨

### 의문점 ...

- **Q1. 코드 생산성의 문제?**
  - 분명 코드량이 늘어남(비즈니스 로직, 각종 코드 디자인도 시간이 소요가 많이 되기 때문에 테스트 코드까지 더해지면 분명히 코드량이 늘어난다.)
  - 결과적으로는 좋은 방법이지만 빠른 생산성이 요구되는 시점에서는 큰 걸림돌이 될 수 있음
- **Q2. 테스트 코드는 작성하기 쉽나?**
  - 진입장벽이 존재
  - 어떤 부분을 테스트 해야하는지, 어떻게 테스트 해야할 지, 여러 테스트 프레임워크 중 어떤 것이 우리의 서비스와 맞는지 학습이 필요, 익숙해지는데 시간도 걸릴 것임
  - 팀에서 한 명만 익숙하다고 해결될 일이 아니며, 팀 단위로 수행되는 개발은 팀원 전체가 익숙해져야 테스트코드의 이점을 살릴 수 있을 것임
- **Q3. 모든 상황에 대해서 테스트 코드를 작성해야하나?**
  - 모든 코드에 대해서 테스트 코드를 작성할 수 없으며 작성할 필요도 없음\*\*\*\*
  - 테스트 코드를 작성한다고 해서 버그가 발생하지 않는 것도 아님
  - 애초에 TDD 는 100% coverage 와 100% 무결성을 주장하지 않았다.

## 함수형 프로그래밍

**immutable data와 first class citizen으로서의 function**

### immutable vs mutable

- **immutable**
  - 변경 불가능
  - `immutable 객체` : 객체가 가지고 있는 값을 변경할 수 없는 객체
  - 값이 변경될 경우 새로운 객체 생성, 변경된 값 주입하여 반환
- **mutable**
  - 객체 값 변경 가능

### first-class citizen

- 함수형 프로그래밍 패러다임을 따르고 있는 언어에서의 함수는 `firt class citizen(일급 객체)` 로 간주
- 일급 객체
  - 변수나 데이터 구조 안에 함수를 담을 수 있어 함수의 파라미터로 전달 가능, 함수의 반환값으로 사용 가능
  - 할당에 사용된 이름과 관계없이 고유한 구별 가능
  - 함수를 리터럴로 바로 정의 가능

## 가비지컬렉터

### 메모리 생존주기

메모리 생존주기는 프로그래밍 언어와 관계없이 아래 과정으로 동작

1. 필요한 메모리 할당
2. 할당된 메모리 사용(읽기, 쓰기)
3. 해당 메모리가 필요 없어지면 해제

1, 3번은 저수준 언어에서는 명시적, 대부분의 고수준 언어에서는 암묵적으로 작동

### 자바스크립트의 메모리 관리

- C언어 같은 저수준 언어는 메모리 관리를 위해 `malloc()`과 `free()`를 직접 명시함으로써 메모리를 관리
- 자바스크립트의 경우 **가비지 컬렉터**가 객체가 생성되었을 때 자동으로 메모리를 할당하고 해당 메모리가 필요 없어지면 자동으로 해제

### 1. 메모리 할당

- 값 초기화
- 프로그래머가 일일이 메모리 할당을 하지 않도록, 자바스크립트는 값을 초기화할 때 자동으로 메모리를 할당

```jsx
let n = 123; // 정수 담기 위한 메모리 할당
let s = 'abcde'; // 문자열 담기 위한 메모리 할당

let o = {
  a: 1,
  b: null,
}; // 오브젝트와 오브젝트에 포함된 값들을 담기 위한 메모리 할당

let a = [1, null, 'abcd']; // 배열과 배열에 담긴 값 담기 위한 메모리 할당

function f(a) {
  return a + 2;
} // 함수 위한 할당
```

- 함수 호출을 통한 메모리 할당
- 함수 호출의 결과로 메모리 할당

```jsx
let d = new Date();
let e = document.createElement('div');
```

- 메소드가 새로운 값이나 오브젝트를 할당

### 2. 값(메모리) 사용

- 할당된 메모리를 읽고 쓰는 것으로, 변수나 객체 속성의 값을 읽고 쓰거나 함수 호출시 함수에 인수를 전달하여 수행

### 3. 메모리 해제

- 할당된 메모리가 더 이상 필요없을 때 할당 해제를 하는데, 해당 단계에서 대부분의 문제가 발생 ("할당된 메모리가 더 이상 필요없을 때"를 알아내기가 어렵기 때문)

위에서 언급한 것과 같이, 저수준 언어에서는 메모리가 필요없어질 때를 개발자가 직접 결정하고 해제하는 방식을 사용

자바스크립트와 같은 고수준 언어들은 **가비지 컬렉션(GC)** 이라는 자동 메모리 관리 방법을 사용

가비지 컬렉터의 목적은 메모리 할당을 추적하고 할당된 메모리 블록이 더이상 필요하지 않은 시점을 판단하여 회수하는 것...
