# FrontEnd

## event

### event bubbling

- 이벤트가 발생했을 때 상위 요소들로 이벤트가 전달되어가는 특성
- 자식에서 발생한 이벤트가 부모로 전파됨

### event capturing

- 브라우저로부터 이벤트가 발생한 요소까지 이벤트 전달
- 버블링과 정반대 …

  ```jsx
  target.addEventListener('click', function () {}, true);
  // true => 캡처링됨
  ```

### event.stopPropagation()

- 이벤트의 전파 막기

  ```jsx
  target.addEventListener('click', function (e) {
    e.stopPropagation();
  });
  ```

### 이벤트 위임?

- 버블링과 캡처링을 통해 이벤트 위임 …
- 하위 요소의 이벤트를 상위 요소에 위임 === 하위 요소의 이벤트를 상위 요소에서 제어
- 상위 요소에서 계속 감시하다가 하위 요소에서 이벤트 발생 시 상위 요소에서 제어

### event.target

- 부모 요소의 핸들러는 이벤트가 정확히 어디서 발생했는지 알 수 있음
- 이벤트가 발생한 가장 안쪽의 요소는 target 요소, `event.target` 으로 접근
- `event.target` : 실제 이벤트가 시작된 타깃 요소, 버블링이 진행되어도 변하지 X(자식)
- `this(event.currentTarget)` : 현재 요소, 현재 실행중인 **핸들러가 할당된** 요소 참조

### e.preventDefault()

- 브라우저에서 처리되는 기존 액션이 진행되지 않게 ….
- html에서 제공하는 기본 이벤트 방지 (form의 submit 전송 및 새로고침 또는 a의 href 를 통해 특정 사이트로 이동)

  ```jsx
  const handleClick = (test) => (e) => [
    e.preventDefault();
    console.log(e);
    console.log(test);
  }}

  <button onClick={handleClick('test')} />버튼</button>
  ```

### 커링(Currying)

- function(a, b, c) 처럼 단일 호출로 처리하는 함수를 f(a)(b)(c)와 같이 각각의 인수가 호출 가능한 프로세스로 호출된 후 병합되도록 변환하는 것

  ```jsx
  function handle(a) {
    return function (b) {
      console.log(a, b);
      return function (c) {
        console.log(a, b, c);
      };
    };
  }
  // 호출
  handle(1)(2)(3);
  ```

  ```jsx
  const handle = (a) => (b) => (c) => {
    console.log(a, b, c);
  };
  // 호출
  handle(1)(2)(3);
  ```

## 즉시실행함수(IIFE, Immediately Invoked Function Expression)

- 정의되자마자 즉시 실행되는 함수

  ```jsx
  (function () {
    statements;
  })();

  (() => {
    statements;
  })();
  ```

- 첫번째는 괄호로 둘러싸인 익명함수
  - 전역 스코프에 불필요한 변수를 추가해서 오염시키는 것을 방지
  - 즉시실행함수 내부 안으로 다른 변수들이 접근하는 것을 막을 수 있는 방법
- 두번째는 즉시실행함수를 생성하는 괄호

  ```jsx
  let result = (function () {
    let name = 'dahye';
    return name;
  })();

  result; //dahye
  // 변수를 할당하면 함수 자체는 저장되지 않고 함수가 실행된 결과를 저장
  ```

사용 이유

- 필요없는 전역변수 생성 줄임
- private한 변수 생성 가능

`useEffect` 는 `clean up` 함수 외에 아무것도 반환하지 않음,

그럼 `useEffect` 안에서 비동기 함수 실행 하려면 ?????

- 비동기 함수를 `useEffect` 외부에서 정의 후 `useEffect` 에서 호출

  ```jsx
  const getPosts = async () => {
    const posts = await axios.get('url');
    setPosts(posts.data);
  };

  useEffect(() => {
    getPosts();
  }, []);
  ```

- 비동기 함수를 `useEffect` 내부에서 정의 후 `useEffect` 에서 호출

  ```jsx
  useEffect(() => {
    const getPosts = async () => {
      const posts = await axios.get('url');
      setPosts(posts.data);
    };

    getPosts();
  }, []);
  ```

- 즉시실행함수 사용

## web

- HTTP 프로토콜은 비연결을 지향하고 상태정보를 유지하지 않음
- 그래서 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나고 상태정보를 유지하지 않음
  = 현재 접속한 사용자가 이전에 접속했던 사용자인지 서버입장에서는 알 수 없음
  = 클라이언트 입장에서는 매 요청마다 인증을 해야 하는 단점 발생
- 이를 위해 서버는 요청에 대한 응답을 할 때 **쿠키**를 같이 보냄(key-value쌍)
- 클라가 서버로부터 쿠키를 받으면 웹브라우저는 쿠키를 저장해두었다가 다음 요청때마다 쿠키를 함께 보냄

### cookie

- HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
- 브라우저는 쿠키들을 저장해놓았다가 동일한 서버에 재요청시 쿠키를 함께 전송
- 쿠키는 요청이 동일한 브라우저에서 들어왔는지 판단할 때 사용 ⇒ 로그인 상태 유지
- 예시) 자동로그인, 쇼핑몰의 장바구니, 오늘 더이상 이창을 보지않음 팝업창

**목적**

- 세션 관리(서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리)
- 개인화(사용자 선호, 테마 등의 세팅)
- 트래킹(사용자 행동을 기록하고 분석하는 용도)

**쿠키 만들기**

- HTTP 요청을 수신할 때 서버는 응답과 함께 `Set-Cookie` 헤더 전송
- 쿠키는 브라우저에 의해 저장됨
- 그 후 쿠키는 같은 서버에 의해 만들어진 요청들의 Cookie HTTP 헤더 안에 포함되어 전송됨
- 만료일 또는 지속시간(duration)도 명시될 수 있음
  - 만료된 쿠키는 더이상 보내지지않음
- 특정 도메인 또는 경로 제한 설정 가능(쿠키 보내지는 것 제한)

**쿠키의 라이프타임**

- 세션 쿠키는 현재 세션이 끝날 때 삭제됨, 브라우저는 "현재 세션"이 끝나는 시점을 정의하며, 어떤 브라우저들은 재시작할 때 세션을 복원해 세션 쿠키가 무기한 존재할 수 있도록 함
- 영속적인 쿠키는 `Expires` 속성에 명시된 날짜에 삭제되거나, `Max-Age` 속성에 명시된 기간 이후에 삭제

**쿠키 구성요소**

- 이름(name)
- 값(value)
- 만료시간(Expires)
- 전송할 도메인 이름(Domain)
- 전송할 경로(Path)
- 보안 연결 여부(Secure)
- HttpOnly 여부(HttpOnly)

**쿠키 동작방식**

- 웹 브라우저가 서버에 요청
- 서버는 상태 유지를 위한 값을 쿠키로 생성
- 서버 응답 시, HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송 `Set−Cookie: id=doy`
- 전달받은 쿠키는 웹 브라우저에서 관리하고, 다음 요청시 쿠키를 HTTP 헤더에 넣어 전송 `cookie: id=doy`
- 서버는 쿠키를 읽어 이전 상태와 확인하고 응답

### session

- **쿠키**를 기반으로 하지만 사용자 정보 파일을 브라우저가 아닌 서버에서 관리하는 방식은 **세션**
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하여 인증상태 유지
  - 접속시간에 제한을 두어 일정 시간 응답이 없으면 정보가 유지되지 않게 설정 가능
- 서버는 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지
  = 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안이 좋지만, 사용자가 많아질 수록 서버 메모리를 많이 차지하게 되어 동접자가 많을 때 **서버에 과부하 발생**

**세션 동작방식**

- 웹 브라우저가 서버에 요청
- 서버는 해당 웹 브라우저에 유일한 세션 ID 부여
- 서버가 응답할 때 HTTP 헤더에 세션 ID 포함해서 전송 `Set−Cookie: JSESSIONID=xslei13f`
- 웹 브라우저는 이후 웹 브라우저를 닫기까지 다음 요청 때 받은 세션 ID가 담겨있는 쿠키를 HTTP헤더에 넣어 전송
  `Cookie: JSESSIONID=xslei13f`
- 서버는 세션 ID를 확인하고 해당 세션에 관련된 정보를 확인한 후 응답
  ⇒ 브라우저 종료시 만료시간과 관계없이 세션 ID 삭제됨

⇒ 세션도 쿠키를 사용하여 값을 주고 받으며 클라이언트의 상태 정보를 유지, 상태 유지는 쿠키가 …

### 쿠키와 세션의 차이점

- 저장 위치
  - 쿠키 : 클라이언트
  - 세션 : 서버
- 보안
  - 쿠키 : 클라이언트에 저장되므로 보안에 취약
  - 세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋음
- 라이프사이클
  - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있음
  - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨
- 속도
  - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠름
  - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느림

## 웹 스토리지

- 웹 스토리지는 기존 쿠키의 문제점을 극복하기 위해 웹 브라우저가 직접 데이터를 저장할 수 있게 함
- 최소 5MB 이상의 많은 공간을 가지고 있고, 이 정보는 서버로 절대 전송되지 않음
- 세션 스토리지와 로컬 스토리지 객체는 동일한 메서드와 프로퍼티를 제공
  - `setItem(key,value)` : 키-값 쌍 보관
  - `getItem(key)` : 키에 해당하는 값을 받아옴
  - `removeItem(key)` : 키와 해당 값을 삭제
  - `clear()` : 모든 것을 삭제
  - `key(index)` : 인덱스에 해당하는 키를 받아옴
  - `length` : 저장된 항목의 개수를 얻음

### session Storage

- 하나의 세션만을 위한 데이터를 저장하는 객체
- 각각의 출처에 대해 독립적인 저장공간을 페이지 세션이 유지되는 동안(브라우저가 열려있는 동안) 제공
- 세션에 한정해, 브라우저가 닫힐 때까지만 데이터 저장
- 데이터를 서버로 전송하지 X
- 저장공간이 쿠키보다 큼

### local Storage

- 보관기한이 없는 데이터를 저장할 수 있는 객체
- 브라우저를 닫았다가 열어도, OS를 재시작하더라도 데이터가 남아있음
- 유효기간없이 데이터 저장, JS를 사용하거나 브라우저 캐시 또는 로컬 저장 데이터를 지워야만 사라짐
- 저장공간이 가장 큼
- 키와 값은 반드시 **문자열**
  - JSON 사용 시 객체 가능

**Storage 이벤트**

- `local Storage` 나 `session Storage` 의 데이터가 갱신될 때, `storage event` 가 실행됨
  - `key` – 변경된 데이터의 키(`.clear()`를 호출했다면 `null`)
  - `oldValue` – 이전 값(키가 새롭게 추가되었다면 `null`)
  - `newValue` – 새로운 값(키가 삭제되었다면 `null`)
  - `url` – 갱신이 일어난 문서의 url
  - `storageArea` – 갱신이 일어난 `localStorage`나 `sessionStorage` 객체

**요약**

웹 스토리지 객체 `localStorage`와 `sessionStorage`를 사용하면 브라우저에 키-값 쌍을 저장 가능

- `키`와 `값`은 반드시 문자열
- 제한 용량은 5MB 이상인데, 브라우저에 따라 다를 수 있음
- 파기되지 않음
- 오리진(도메인·포트·프로토콜)에 묶여있음

## MouseEvent 속성 및 메서드

- `clientX` : 마우스 이벤트가 트리거되었을 때 **현재 창**을 기준으로 마우스 포인터의 수평 좌표를 반환
  - 클라이언트 영역 내 좌표, 현재 보이는 브라우저
- `clientY` : 마우스 이벤트가 트리거되었을 때 **현재 창**을 기준으로 마우스 포인터의 수직 좌표를 반환
  - 스크롤 무시, 해당 페이지의 상단을 0으로
- `offsetX` : **대상 요소의 가장자리 위치**를 기준으로 마우스 포인터의 수평 좌표를 반환
  - 이벤트 대상이 기준
- `offsetY` : **대상 요소의 가장자리 위치**를 기준으로 마우스 포인터의 수직 좌표를 반환
- `pageX` : 마우스 이벤트가 트리거되었을 때 **문서**를 기준으로 마우스 포인터의 수평 좌표를 반환
  - 전체 문서 기준, 스크롤 화면 포함하여 측정
- `pageY` : 마우스 이벤트가 트리거되었을 때 **문서**를 기준으로 마우스 포인터의 수직 좌표를 반환
- `screenX` : 이벤트가 트리거되었을 때 **화면**을 기준으로 마우스 포인터의 수평 좌표를 반환
  - 전체 모니터 스크린 기준
- `screenY` : 이벤트가 트리거되었을 때 **화면**을 기준으로 마우스 포인터의 수직 좌표를 반환

### 이벤트 유형

- `onmousedown` : 사용자가 요소 위에 마우스 버튼을 누르면 이벤트가 발생
- `onmouseenter` : 포인터를 요소 위로 이동하면 이벤트가 발생
- `onmouseleave` : 포인터가 요소 밖으로 이동될 때 이벤트가 발생
- `onmousemove` : 포인터가 요소 위에 있는 동안 포인터가 이동할 때 이벤트가 발생
- `onmouseout` : 사용자가 요소 또는 하위 요소 중 하나에서 마우스 포인터를 이동할 때 발생
- `onmouseover` : 포인터가 요소 또는 해당 하위 요소 중 하나로 이동될 때 이벤트가 발생
- `onmouseup` : 사용자가 요소 위에 마우스 버튼을 놓으면 이벤트가 발생

### Event Trigger

브라우저마다 기본 UI 스타일이 다른 엘리먼트가 존재

보통 `<input type="file" />` 의 경우에도 Chrome과 IE에서의 출력 디자인이 다름

따라서 공통된 style을 제공하기 위해 input태그가 아닌 다른 버튼을 추가로 만들어 연결해주는 방식을 이벤트 트리거라고 함

`element.dispatchEvent(event)`

## 토큰

- HTTP는 `stateless` 특성을 가지고 있음
  - `stateless` : 서버가 클라이언트의 세션 상태 및 세션 정보를 저장하지 않는 …

### 토큰 기반 인증

- 사용자가 자신의 `identity`를 확인하고 고유한 `access token` 을 발급받을 수 있는 프로토콜
- 사용자는 `token` 의 유효기간 동안 동일한 리소스로 돌아갈 때마다 자격 증명을 다시 입력할 필요 없이 액세스 가능
- 토큰 기반 인증은 비밀번호 기반 또는 서버 기반 인증 기법과는 다름
- 인증 토큰 유형
  - 연결형: 키, 디스크, 드라이브 및 기타 물리적 장치가 시스템에 연결되어 액세스를 허용(ex. usb, 스마트카드 등)
  - 비접촉형: 디바이스가 서버와 근거리에서 통신(ex. Microsoft 의 매직링)
  - 분리형: 디바이스가 다른 디바이스와 접촉하지 않고도 먼 거리에서 서버와 통신(이중 요소 프로세스에 핸드폰 사용)
- 토큰 기반 인증 시스템을 사용하면 사용자는 자격 증명을 한번 확인, 확인되면 토큰이 할당되고 정해진 시간 동안 액세스 가능
- 토큰 인증 절차
  - **요청**: 사용자가 서버 또는 보호되는 리소스에 대한 액세스 요청
  - **확인**: 서버가 해당 사용자의 액세스 여부 확인
  - **토큰**: 서버가 링, 키, 휴대전화 등의 인증 디바이스와 통신하고 확인 후 서버가 토큰을 발급하여 사용자에게 전달
  - **저장**: 작업이 지속되는 동안 토큰이 사용자의 브라우저에 저장
    사용자가 서버에서 다른 곳에 방문하려고 하면 토큰이 서버와 다시 통신, 토큰에 따라 액세스 허용 결정
    관리자가 토큰에 대한 사용 제한을 설정하기도 함
