# FrontEnd

## event

### event bubbling

- 이벤트가 발생했을 때 상위 요소들로 이벤트가 전달되어가는 특성
- 자식에서 발생한 이벤트가 부모로 전파됨

### event capturing

- 브라우저로부터 이벤트가 발생한 요소까지 이벤트 전달
- 버블링과 정반대 …

  ```jsx
  target.addEventListener('click', function () {}, true);
  // true => 캡처링됨
  ```

### event.stopPropagation()

- 이벤트의 전파 막기

  ```jsx
  target.addEventListener('click', function (e) {
    e.stopPropagation();
  });
  ```

### 이벤트 위임?

- 버블링과 캡처링을 통해 이벤트 위임 …
- 하위 요소의 이벤트를 상위 요소에 위임 === 하위 요소의 이벤트를 상위 요소에서 제어
- 상위 요소에서 계속 감시하다가 하위 요소에서 이벤트 발생 시 상위 요소에서 제어

### event.target

- 부모 요소의 핸들러는 이벤트가 정확히 어디서 발생했는지 알 수 있음
- 이벤트가 발생한 가장 안쪽의 요소는 target 요소, `event.target` 으로 접근
- `event.target` : 실제 이벤트가 시작된 타깃 요소, 버블링이 진행되어도 변하지 X(자식)
- `this(event.currentTarget)` : 현재 요소, 현재 실행중인 **핸들러가 할당된** 요소 참조

### e.preventDefault()

- 브라우저에서 처리되는 기존 액션이 진행되지 않게 ….
- html에서 제공하는 기본 이벤트 방지 (form의 submit 전송 및 새로고침 또는 a의 href 를 통해 특정 사이트로 이동)

  ```jsx
  const handleClick = (test) => (e) => [
    e.preventDefault();
    console.log(e);
    console.log(test);
  }}

  <button onClick={handleClick('test')} />버튼</button>
  ```

### 커링(Currying)

- function(a, b, c) 처럼 단일 호출로 처리하는 함수를 f(a)(b)(c)와 같이 각각의 인수가 호출 가능한 프로세스로 호출된 후 병합되도록 변환하는 것

  ```jsx
  function handle(a) {
    return function (b) {
      console.log(a, b);
      return function (c) {
        console.log(a, b, c);
      };
    };
  }
  // 호출
  handle(1)(2)(3);
  ```

  ```jsx
  const handle = (a) => (b) => (c) => {
    console.log(a, b, c);
  };
  // 호출
  handle(1)(2)(3);
  ```

## 즉시실행함수(IIFE, Immediately Invoked Function Expression)

- 정의되자마자 즉시 실행되는 함수

  ```jsx
  (function () {
    statements;
  })();

  (() => {
    statements;
  })();
  ```

- 첫번째는 괄호로 둘러싸인 익명함수
  - 전역 스코프에 불필요한 변수를 추가해서 오염시키는 것을 방지
  - 즉시실행함수 내부 안으로 다른 변수들이 접근하는 것을 막을 수 있는 방법
- 두번째는 즉시실행함수를 생성하는 괄호

  ```jsx
  let result = (function () {
    let name = 'dahye';
    return name;
  })();

  result; //dahye
  // 변수를 할당하면 함수 자체는 저장되지 않고 함수가 실행된 결과를 저장
  ```

사용 이유

- 필요없는 전역변수 생성 줄임
- private한 변수 생성 가능

`useEffect` 는 `clean up` 함수 외에 아무것도 반환하지 않음,

그럼 `useEffect` 안에서 비동기 함수 실행 하려면 ?????

- 비동기 함수를 `useEffect` 외부에서 정의 후 `useEffect` 에서 호출

  ```jsx
  const getPosts = async () => {
    const posts = await axios.get('url');
    setPosts(posts.data);
  };

  useEffect(() => {
    getPosts();
  }, []);
  ```

- 비동기 함수를 `useEffect` 내부에서 정의 후 `useEffect` 에서 호출

  ```jsx
  useEffect(() => {
    const getPosts = async () => {
      const posts = await axios.get('url');
      setPosts(posts.data);
    };

    getPosts();
  }, []);
  ```

- 즉시실행함수 사용

## web

- HTTP 프로토콜은 비연결을 지향하고 상태정보를 유지하지 않음
- 그래서 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나고 상태정보를 유지하지 않음
  = 현재 접속한 사용자가 이전에 접속했던 사용자인지 서버입장에서는 알 수 없음
  = 클라이언트 입장에서는 매 요청마다 인증을 해야 하는 단점 발생
- 이를 위해 서버는 요청에 대한 응답을 할 때 **쿠키**를 같이 보냄(key-value쌍)
- 클라가 서버로부터 쿠키를 받으면 웹브라우저는 쿠키를 저장해두었다가 다음 요청때마다 쿠키를 함께 보냄

### cookie

- HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
- 브라우저는 쿠키들을 저장해놓았다가 동일한 서버에 재요청시 쿠키를 함께 전송
- 쿠키는 요청이 동일한 브라우저에서 들어왔는지 판단할 때 사용 ⇒ 로그인 상태 유지
- 예시) 자동로그인, 쇼핑몰의 장바구니, 오늘 더이상 이창을 보지않음 팝업창

**목적**

- 세션 관리(서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리)
- 개인화(사용자 선호, 테마 등의 세팅)
- 트래킹(사용자 행동을 기록하고 분석하는 용도)

**쿠키 만들기**

- HTTP 요청을 수신할 때 서버는 응답과 함께 `Set-Cookie` 헤더 전송
- 쿠키는 브라우저에 의해 저장됨
- 그 후 쿠키는 같은 서버에 의해 만들어진 요청들의 Cookie HTTP 헤더 안에 포함되어 전송됨
- 만료일 또는 지속시간(duration)도 명시될 수 있음
  - 만료된 쿠키는 더이상 보내지지않음
- 특정 도메인 또는 경로 제한 설정 가능(쿠키 보내지는 것 제한)

**쿠키의 라이프타임**

- 세션 쿠키는 현재 세션이 끝날 때 삭제됨, 브라우저는 "현재 세션"이 끝나는 시점을 정의하며, 어떤 브라우저들은 재시작할 때 세션을 복원해 세션 쿠키가 무기한 존재할 수 있도록 함
- 영속적인 쿠키는 `Expires` 속성에 명시된 날짜에 삭제되거나, `Max-Age` 속성에 명시된 기간 이후에 삭제

**쿠키 구성요소**

- 이름(name)
- 값(value)
- 만료시간(Expires)
- 전송할 도메인 이름(Domain)
- 전송할 경로(Path)
- 보안 연결 여부(Secure)
- HttpOnly 여부(HttpOnly)

**쿠키 동작방식**

- 웹 브라우저가 서버에 요청
- 서버는 상태 유지를 위한 값을 쿠키로 생성
- 서버 응답 시, HTTP 헤더(Set-Cookie)에 쿠키를 포함해서 전송 `Set−Cookie: id=doy`
- 전달받은 쿠키는 웹 브라우저에서 관리하고, 다음 요청시 쿠키를 HTTP 헤더에 넣어 전송 `cookie: id=doy`
- 서버는 쿠키를 읽어 이전 상태와 확인하고 응답

### session

- **쿠키**를 기반으로 하지만 사용자 정보 파일을 브라우저가 아닌 서버에서 관리하는 방식은 **세션**
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하여 인증상태 유지
  - 접속시간에 제한을 두어 일정 시간 응답이 없으면 정보가 유지되지 않게 설정 가능
- 서버는 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지
  = 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안이 좋지만, 사용자가 많아질 수록 서버 메모리를 많이 차지하게 되어 동접자가 많을 때 **서버에 과부하 발생**

**세션 동작방식**

- 웹 브라우저가 서버에 요청
- 서버는 해당 웹 브라우저에 유일한 세션 ID 부여
- 서버가 응답할 때 HTTP 헤더에 세션 ID 포함해서 전송 `Set−Cookie: JSESSIONID=xslei13f`
- 웹 브라우저는 이후 웹 브라우저를 닫기까지 다음 요청 때 받은 세션 ID가 담겨있는 쿠키를 HTTP헤더에 넣어 전송
  `Cookie: JSESSIONID=xslei13f`
- 서버는 세션 ID를 확인하고 해당 세션에 관련된 정보를 확인한 후 응답
  ⇒ 브라우저 종료시 만료시간과 관계없이 세션 ID 삭제됨

⇒ 세션도 쿠키를 사용하여 값을 주고 받으며 클라이언트의 상태 정보를 유지, 상태 유지는 쿠키가 …

### 쿠키와 세션의 차이점

- 저장 위치
  - 쿠키 : 클라이언트
  - 세션 : 서버
- 보안
  - 쿠키 : 클라이언트에 저장되므로 보안에 취약
  - 세션 : 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋음
- 라이프사이클
  - 쿠키 : 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있음
  - 세션 : 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됨
- 속도
  - 쿠키 : 클라이언트에 저장되어서 서버에 요청 시 빠름
  - 세션 : 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느림

### 웹 스토리지

- 웹 스토리지는 기존 쿠키의 문제점을 극복하기 위해 웹 브라우저가 직접 데이터를 저장할 수 있게 함
- 최소 5MB 이상의 많은 공간을 가지고 있고, 이 정보는 서버로 절대 전송되지 않음

**sesstion Storage**

- 하나의 세션만을 위한 데이터를 저장하는 객체
- 각각의 출처에 대해 독립적인 저장공간을 페이지 세션이 유지되는 동안(브라우저가 열려있는 동안) 제공
- 세션에 한정해, 브라우저가 닫힐 때까지만 데이터 저장
- 데이터를 서버로 전송하지 X
- 저장공간이 쿠키보다 큼

**local Storage**

- 보관기한이 없는 데이터를 저장할 수 있는 객체
- 브라우저를 닫았다가 열어도 데이터가 남아있음
- 유효기간없이 데이터 저장, JS를 사용하거나 브라우저 캐시 또는 로컬 저장 데이터를 지워야만 사라짐
- 저장공간이 가장 큼
