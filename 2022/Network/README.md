# Network

## 인터넷 기본 동작 과정

**컴퓨터는 모든 정보를 0과 1로 저장**

하나의 컴퓨터가 다른 컴퓨터에게 정보를 전달하는 것은 수많은 0과 1의 시퀀스를 전달하는 것

두 개의 컴퓨터를 전선으로 연결하여 정보를 전달할 수 있게 함


→ 이 때,  다른 사람도 통신하고 싶다고 함!

→ 통신을 원하는 사람들이 점점 늘어나면 필요한 전선의 양은 수없이 늘어날 것

ex) 10대의 컴퓨터가 서로 연결되기 위해서는 9개의 플러그가 달린 각각의 컴퓨터와 45개의 전선 필요


이를 위해 하나의 전선을 중앙에 놓고, 각 컴퓨터는 중앙의 전선과 연결한다면 필요한 플러그와 전선의 수를 줄일 수 있음

하지만 모든 컴퓨터가 단일한 경로로 연결되어있기 때문에 한쪽에서 보내는 정보를 다른 모든 컴퓨터에서 수신 가능 A가 B에게 보내는 메시지를 다른 모두가 볼 수 있음

`스위치` : 한쪽에서 송신한 메시지를 원하는 쪽만 수신할 수 있도록 경로를 연결


`네트워크` : 컴퓨터들이 서로 연결된 하나의 그룹

다른 네트워크와 통신을 하려면?

`라우터` : 서로 다른 네트워크와의 통신을 위해 스위치와 스위치를 서로 연결


**라우터는 또 다른 라우터와 연결 가능**

⇒ **이 모든 것은 물리적으로 연결되어있음, 이런 연결을 담당해주는 곳이 인터넷 서비스 제공자**

`ISP(Internet Service Provider)` : 몇몇 특별한 라우터, 그리고 다른 ISP의 라우터와 연결하는 회사 (우리나라에는 KT, LG, SKT)

우리는 다른 네트워크와의 전기선을 직접 연결하는 것이 아니라 ISP를 통해 간접적으로 연결

우리나라에서 미국과 통신을 하려면 한국 ISP - 일본 ISP - 미국 ISP 를 통해 통신


해저 광케이블을 통해 물리적으로 직접 연결되어있음

**인터넷(네트워크들의 네트워크)** ⇒ 전 세계의 모든 컴퓨터, 이들이 속해있는 각각의 독립적인 네트워크들이 거대한 네트워크를 이루고 있는 것

## HTTP 와 HTTPS

### HTTP

- HyperText Transfer Protocol
- W3 상에서 정보를 주고 받을 수 있는 Protocol
- 주로 `TCP` 사용, HTTP/3 부터는 `UDP` 사용
- 80번 포트

### HTTP의 문제점

- HTTP는 평문 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

### TCP/IP 는 도청 가능한 네트워크

- `TCP/IP` 구조 통신은 전부 통신 경로 상에서 엿볼 수 있음 === 패킷을 수집하는 것 만으로 도청 가능
- 평문으로 통신할 경우 메시지 의미를 파악할 수 있기 때문에 암호화하여 통신해야함

**[보완 방법]**

⇒ 통신 자체를 암호화 `SSL` OR `TLS` 를 조합함으로써 HTTP의 통신 내용 암호화

(`SSL` 을 조합한 HTTP는 `HTTPS` OR `HTTP over SSL` )

⇒ HTTP 메시지에 포함되는 콘텐츠를 암호화

### 통신 상대를 확인하지 않기 때문에 위장 가능

- HTTP 통신은 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 요청 전송 가능
- IP 주소나 포트 등에서 해당 웹 서버에 액세스 제한이 없는 경우 요청이 오면 상대가 누구든 응답
  - 요청을 보낸 곳의 웹 서버가 원래 의도한 응답을 보내야 하는 웹 서버인지 확인 불가능
  - 응답을 반환한 곳의 클라이언트가 원래 의도한 요청을 보낸 클라이언트인지 확인 불가능
  - 통신하고 있는 상대가 접근이 허가된 상대인지 확인 불가능
  - 어디에서 누가 요청했는지 확인 불가능
  - 의미 없는 요청도 수신하게 됨 → DoS 공격 방지 X

**[보완 방법]**

⇒ `SSL` 은 상대를 확인하는 수단으로 **증명서** 제공

증명서는 제 3자 기관에 의해 발행되는 것으로 서버나 클라이언트가 실재하는 사실 증명

클라이언트는 해당 증명서로 본인을 확인하고 웹 사이트 인증도 이용 가능

### 완전성(정보의 정확성)을 증명할 수 없기 때문에 변조 가능

- 서버 OR 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치하는지 보장할 수 없음
- 요청이나 응답이 발신된 후에 상대가 수신하는 사이 누군가에 의해 변조될 수도 있음
  - 중간자 공격(Man-in-the-Middle): 공격자가 도중에 요청이나 응답을 변조

**[보완 방법]**

⇒ `MD5`, `SHA-1` 등 해시값 확인, 파일의 디지털 서명을 확인하는 방법이 있지만 확실한 것은 X

⇒ HTTPS의 `SSL` 로 인증, 암호화, 다이제스트 기능을 통해 보완 가능

### HTTPS

> HTTP에 암호화와 인증, 완전성 보호를 더한 것이 HTTPS
>
- `SSL` 이 추가된 HTTP의 보안이 강화된 버전
- HyperText Protocol over Secure Socket Layer
- HTTP 통신하는 소켓 부분을 `SSL(Secure Socket Layer)` OR `TLS(Transport Layer Security)` 프로토콜로 대체하는 것
- HTTP는 `SSL` 과 통신, `SSL` 이 `TCP` 와 통신
- 암호화와 증명서, 안전성 보호 가능
- `SSL` 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합하여 하이브리드 암호 시스템 사용
- 공통키를 공개키 암호화 방식으로 교환하고 공통키 암호 방식을 사용하여 통신

**모든 웹 페이지에서 HTTPS 를 사용해도되는가?**

- 평문 통신에 비해 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구
- 통신할 때마다 암호화를 하면 추가적 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 요청의 수가 상대적으로 줄어듬
- 하지만 최근 하드웨어의 발달로 HTTPS를 사용하더라도 속도 저하가 거의 발생하지 않음
- 새로운 표준 HTTP 2.0을 함께 이용하면 오히려 HTTP보다 빠르게 동작
- 현재는 거의 모든 웹 페이지에서 HTTPS 를 적용하는 방향으로 변화하고 있음

## HTTP의 GET vs POST

`GET` 과 `POST` 방식은 HTTP 프로토콜을 이용하여 서버에 무엇인가 요청할 때 사용

### GET

- 요청하는 데이터가 `HTTP Request Message` 의 `Header` 부분에 url이 담겨 전송
- url 상에 `?` 뒤에 데이터가 붙어서 요청됨
  - url 에 담겨가기 때문에 전송할 수 있는 데이터 크기가 제한적
  - 보안이 필요한 데이터에 대해서는 데이터가 그대로 url에 노출되어 적절하지 않음
    (ex. password)
- **“데이터를 가져오는 것”**
  - 서버에서 어떤 데이터를 가져와 보여주는 용도
  - 서버의 값이나 상태 등을 변경하지 X
  - `SELECT` 적 성향

### POST

- 요청하는 데이터가 `HTTP Request Message` 의 `Body` 부분에 담겨 전송
- 바이너리 데이터를 요청하는 경우 `POST` 방식을 이용하는데 이처럼 데이터 크기가 `GET` 방식보다 크고 보안 측면에서 `GET` 보다 나음(보안적 측면에서는 암호화하지 않는 이상 고만고만하긴 함)
- **“데이터를 변경, 추가하는 것”**

## TCP 3-way-handshake

### 연결 성립(Connection Establishment)

1. 클라이언트는 서버에 접속을 요청하는 `SYN(a)` 패킷을 보낸다.
2. 서버는 클라이언트의 요청인 `SYN(a)` 을 받고 클라이언트에게 요청을 수락한다는 `ACK(a+1)` 와 `SYN(b)` 이 설정된 패킷을 전송한다.
3. 클라이언트는 서버의 수락 응답인 `ACK(a+1)` 와 `SYN(b)` 패킷을 받고 `ACK(b+1)` 를 서버로 보내면 연결이 성립된다.

### 연결 해제(Connection Termination)


1. 클라이언트가 연결을 종료하겠다는 `FIN` 플래그를 전송한다.
2. 서버는 클라이언트의 요청 `FIN` 을 받고 확인 메시지 `ACK` 를 전송한다.
3. 데이터를 모두 보낼때까지 잠시 `TIME_OUT` 이 된다.
4. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 `FIN` 플래그를 전송한다.
5. 클라이언트는 `FIN` 을 받고 확인 메시지 `ACK` 를 전송한다.
6. 클라이언트의 `ACK` 를 받은 서버는 소켓 연결을 `close` 한다.
7. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비하여 일정 시간 동안 세션을 남겨두고 잉여 패킷을 기다린다. `TIME_WAIT`

### SYN(synchronize sequence number)과 ACK(acknowledgement)

- `TCP Header` 에는 `Code Bit(Flag bit)` 부분이 존재
- 총 6Bit, 각각 비트들이 의미를 가지고 있음 `(Urg-Ack-Psh-Rst-Syn-Fin)`
- 해당 위치의 비트가 1이면 해당 패킷이 어떤 내용을 담는 패킷인지 나타남
- `SYN` 패킷의 경우 `000010` , `ACK` 패킷의 경우 `010000`

**왜 3-way 일까?**

- 클라이언트 → 서버 ( 내 목소리 들려?)
- 서버 → 클라이언트 ( 웅 너 목소리 들려. 너는 내 목소리 들려?)
- 클라이언트 → 서버 ( 웅 나도 너 목소리 들려)

`TCP` 는 양방향성으로 클라이언트와 서버가 서로 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 함

**ISN(초기 sequence number) 이 난수인 이유는?**

- 처음 클라이언트에서 `SYN` 패킷을 보낼 때 `Sequence Number`에는 랜덤한 숫자가 담겨짐
- Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용됨 ⇒ 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성 존재 ⇒ 서버는 패킷의 `SYN` 을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적 숫자가 전송되면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있음

## TCP와 UDP

### UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)

- 비연결형 프로토콜
- IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법 제공
- 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않음 ⇒사용자 프로세스의 몫
- 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것
- `UDP` 를 사용한 것들에는 `DNS` 가 있음
- 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 `DNS` 서버로 호스트 네임을 포함한 `UDP` 패킷을 보냄
- 이 서버는 호스트의 `IP` 주소를 포함한 `UDP` 패킷으로 응답
- 사전에 설정 필요 X, 후에 해제 필요 X

### TCP(Transmission Control Protocol, 전송제어프로토콜)

- 대부분 인터넷 응용 분야들은 신뢰성과 순차적 전달을 필요로 함
- `UDP` 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 `TCP`
- 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 설계됨
- 송신자와 수신자 모두 소켓이라고 부르는 종단점을 생성함으로서 이루어짐
- `TCP` 에서 연결 설정은 `3-way-handshake` 를 통해 이루어짐
- 모든 `TCP` 연결은 **전이중(full-duplex), 점대점(point to point) 방식**
- **전이중**: 전송이 양방향으로 동시에 일어날 수 있음을 의미
- **점대점**: 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미
- 멀티캐스팅이나 브로드캐스팅을 지원하지 않음