# Network

## 인터넷 기본 동작 과정

**컴퓨터는 모든 정보를 0과 1로 저장**

하나의 컴퓨터가 다른 컴퓨터에게 정보를 전달하는 것은 수많은 0과 1의 시퀀스를 전달하는 것

두 개의 컴퓨터를 전선으로 연결하여 정보를 전달할 수 있게 함


→ 이 때,  다른 사람도 통신하고 싶다고 함!

→ 통신을 원하는 사람들이 점점 늘어나면 필요한 전선의 양은 수없이 늘어날 것

ex) 10대의 컴퓨터가 서로 연결되기 위해서는 9개의 플러그가 달린 각각의 컴퓨터와 45개의 전선 필요


이를 위해 하나의 전선을 중앙에 놓고, 각 컴퓨터는 중앙의 전선과 연결한다면 필요한 플러그와 전선의 수를 줄일 수 있음

하지만 모든 컴퓨터가 단일한 경로로 연결되어있기 때문에 한쪽에서 보내는 정보를 다른 모든 컴퓨터에서 수신 가능 A가 B에게 보내는 메시지를 다른 모두가 볼 수 있음

`스위치` : 한쪽에서 송신한 메시지를 원하는 쪽만 수신할 수 있도록 경로를 연결


`네트워크` : 컴퓨터들이 서로 연결된 하나의 그룹

다른 네트워크와 통신을 하려면?

`라우터` : 서로 다른 네트워크와의 통신을 위해 스위치와 스위치를 서로 연결


**라우터는 또 다른 라우터와 연결 가능**

⇒ **이 모든 것은 물리적으로 연결되어있음, 이런 연결을 담당해주는 곳이 인터넷 서비스 제공자**

`ISP(Internet Service Provider)` : 몇몇 특별한 라우터, 그리고 다른 ISP의 라우터와 연결하는 회사 (우리나라에는 KT, LG, SKT)

우리는 다른 네트워크와의 전기선을 직접 연결하는 것이 아니라 ISP를 통해 간접적으로 연결

우리나라에서 미국과 통신을 하려면 한국 ISP - 일본 ISP - 미국 ISP 를 통해 통신


해저 광케이블을 통해 물리적으로 직접 연결되어있음

**인터넷(네트워크들의 네트워크)** ⇒ 전 세계의 모든 컴퓨터, 이들이 속해있는 각각의 독립적인 네트워크들이 거대한 네트워크를 이루고 있는 것

## HTTP 와 HTTPS

### HTTP

- HyperText Transfer Protocol
- W3 상에서 정보를 주고 받을 수 있는 Protocol
- 주로 `TCP` 사용, HTTP/3 부터는 `UDP` 사용
- 80번 포트

### HTTP의 문제점

- HTTP는 평문 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

### TCP/IP 는 도청 가능한 네트워크

- `TCP/IP` 구조 통신은 전부 통신 경로 상에서 엿볼 수 있음 === 패킷을 수집하는 것 만으로 도청 가능
- 평문으로 통신할 경우 메시지 의미를 파악할 수 있기 때문에 암호화하여 통신해야함

**[보완 방법]**

⇒ 통신 자체를 암호화 `SSL` OR `TLS` 를 조합함으로써 HTTP의 통신 내용 암호화

(`SSL` 을 조합한 HTTP는 `HTTPS` OR `HTTP over SSL` )

⇒ HTTP 메시지에 포함되는 콘텐츠를 암호화

### 통신 상대를 확인하지 않기 때문에 위장 가능

- HTTP 통신은 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 요청 전송 가능
- IP 주소나 포트 등에서 해당 웹 서버에 액세스 제한이 없는 경우 요청이 오면 상대가 누구든 응답
  - 요청을 보낸 곳의 웹 서버가 원래 의도한 응답을 보내야 하는 웹 서버인지 확인 불가능
  - 응답을 반환한 곳의 클라이언트가 원래 의도한 요청을 보낸 클라이언트인지 확인 불가능
  - 통신하고 있는 상대가 접근이 허가된 상대인지 확인 불가능
  - 어디에서 누가 요청했는지 확인 불가능
  - 의미 없는 요청도 수신하게 됨 → DoS 공격 방지 X

**[보완 방법]**

⇒ `SSL` 은 상대를 확인하는 수단으로 **증명서** 제공

증명서는 제 3자 기관에 의해 발행되는 것으로 서버나 클라이언트가 실재하는 사실 증명

클라이언트는 해당 증명서로 본인을 확인하고 웹 사이트 인증도 이용 가능

### 완전성(정보의 정확성)을 증명할 수 없기 때문에 변조 가능

- 서버 OR 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치하는지 보장할 수 없음
- 요청이나 응답이 발신된 후에 상대가 수신하는 사이 누군가에 의해 변조될 수도 있음
  - 중간자 공격(Man-in-the-Middle): 공격자가 도중에 요청이나 응답을 변조

**[보완 방법]**

⇒ `MD5`, `SHA-1` 등 해시값 확인, 파일의 디지털 서명을 확인하는 방법이 있지만 확실한 것은 X

⇒ HTTPS의 `SSL` 로 인증, 암호화, 다이제스트 기능을 통해 보완 가능

### HTTPS

> HTTP에 암호화와 인증, 완전성 보호를 더한 것이 HTTPS
>
- `SSL` 이 추가된 HTTP의 보안이 강화된 버전
- HyperText Protocol over Secure Socket Layer
- HTTP 통신하는 소켓 부분을 `SSL(Secure Socket Layer)` OR `TLS(Transport Layer Security)` 프로토콜로 대체하는 것
- HTTP는 `SSL` 과 통신, `SSL` 이 `TCP` 와 통신
- 암호화와 증명서, 안전성 보호 가능
- `SSL` 에서는 공통키 암호화 방식과 공개키 암호화 방식을 혼합하여 하이브리드 암호 시스템 사용
- 공통키를 공개키 암호화 방식으로 교환하고 공통키 암호 방식을 사용하여 통신

**모든 웹 페이지에서 HTTPS 를 사용해도되는가?**

- 평문 통신에 비해 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구
- 통신할 때마다 암호화를 하면 추가적 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 요청의 수가 상대적으로 줄어듬
- 하지만 최근 하드웨어의 발달로 HTTPS를 사용하더라도 속도 저하가 거의 발생하지 않음
- 새로운 표준 HTTP 2.0을 함께 이용하면 오히려 HTTP보다 빠르게 동작
- 현재는 거의 모든 웹 페이지에서 HTTPS 를 적용하는 방향으로 변화하고 있음

## HTTP의 GET vs POST

`GET` 과 `POST` 방식은 HTTP 프로토콜을 이용하여 서버에 무엇인가 요청할 때 사용

### GET

- 요청하는 데이터가 `HTTP Request Message` 의 `Header` 부분에 url이 담겨 전송
- url 상에 `?` 뒤에 데이터가 붙어서 요청됨
  - url 에 담겨가기 때문에 전송할 수 있는 데이터 크기가 제한적
  - 보안이 필요한 데이터에 대해서는 데이터가 그대로 url에 노출되어 적절하지 않음
    (ex. password)
- **“데이터를 가져오는 것”**
  - 서버에서 어떤 데이터를 가져와 보여주는 용도
  - 서버의 값이나 상태 등을 변경하지 X
  - `SELECT` 적 성향

### POST

- 요청하는 데이터가 `HTTP Request Message` 의 `Body` 부분에 담겨 전송
- 바이너리 데이터를 요청하는 경우 `POST` 방식을 이용하는데 이처럼 데이터 크기가 `GET` 방식보다 크고 보안 측면에서 `GET` 보다 나음(보안적 측면에서는 암호화하지 않는 이상 고만고만하긴 함)
- **“데이터를 변경, 추가하는 것”**

## TCP 3-way-handshake

### 연결 성립(Connection Establishment)

1. 클라이언트는 서버에 접속을 요청하는 `SYN(a)` 패킷을 보낸다.
2. 서버는 클라이언트의 요청인 `SYN(a)` 을 받고 클라이언트에게 요청을 수락한다는 `ACK(a+1)` 와 `SYN(b)` 이 설정된 패킷을 전송한다.
3. 클라이언트는 서버의 수락 응답인 `ACK(a+1)` 와 `SYN(b)` 패킷을 받고 `ACK(b+1)` 를 서버로 보내면 연결이 성립된다.

### 연결 해제(Connection Termination)


1. 클라이언트가 연결을 종료하겠다는 `FIN` 플래그를 전송한다.
2. 서버는 클라이언트의 요청 `FIN` 을 받고 확인 메시지 `ACK` 를 전송한다.
3. 데이터를 모두 보낼때까지 잠시 `TIME_OUT` 이 된다.
4. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 `FIN` 플래그를 전송한다.
5. 클라이언트는 `FIN` 을 받고 확인 메시지 `ACK` 를 전송한다.
6. 클라이언트의 `ACK` 를 받은 서버는 소켓 연결을 `close` 한다.
7. 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비하여 일정 시간 동안 세션을 남겨두고 잉여 패킷을 기다린다. `TIME_WAIT`

### SYN(synchronize sequence number)과 ACK(acknowledgement)

- `TCP Header` 에는 `Code Bit(Flag bit)` 부분이 존재
- 총 6Bit, 각각 비트들이 의미를 가지고 있음 `(Urg-Ack-Psh-Rst-Syn-Fin)`
- 해당 위치의 비트가 1이면 해당 패킷이 어떤 내용을 담는 패킷인지 나타남
- `SYN` 패킷의 경우 `000010` , `ACK` 패킷의 경우 `010000`

**왜 3-way 일까?**

- 클라이언트 → 서버 ( 내 목소리 들려?)
- 서버 → 클라이언트 ( 웅 너 목소리 들려. 너는 내 목소리 들려?)
- 클라이언트 → 서버 ( 웅 나도 너 목소리 들려)

`TCP` 는 양방향성으로 클라이언트와 서버가 서로 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 함

**ISN(초기 sequence number) 이 난수인 이유는?**

- 처음 클라이언트에서 `SYN` 패킷을 보낼 때 `Sequence Number`에는 랜덤한 숫자가 담겨짐
- Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용됨 ⇒ 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성 존재 ⇒ 서버는 패킷의 `SYN` 을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적 숫자가 전송되면 이전의 Connection으로부터 오는 패킷으로 인식할 수 있음

## TCP와 UDP

### UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)

- 비연결형 프로토콜
- IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법 제공
- 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않음 ⇒사용자 프로세스의 몫
- 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것
- `UDP` 를 사용한 것들에는 `DNS` 가 있음
- 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 `DNS` 서버로 호스트 네임을 포함한 `UDP` 패킷을 보냄
- 이 서버는 호스트의 `IP` 주소를 포함한 `UDP` 패킷으로 응답
- 사전에 설정 필요 X, 후에 해제 필요 X

### TCP(Transmission Control Protocol, 전송제어프로토콜)

- 대부분 인터넷 응용 분야들은 신뢰성과 순차적 전달을 필요로 함
- `UDP` 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 `TCP`
- 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 설계됨
- 송신자와 수신자 모두 소켓이라고 부르는 종단점을 생성함으로서 이루어짐
- `TCP` 에서 연결 설정은 `3-way-handshake` 를 통해 이루어짐
- 모든 `TCP` 연결은 **전이중(full-duplex), 점대점(point to point) 방식**
- **전이중**: 전송이 양방향으로 동시에 일어날 수 있음을 의미
- **점대점**: 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미
- 멀티캐스팅이나 브로드캐스팅을 지원하지 않음

## www.google.com을 검색하면?

### 1. www.google.com을 브라우저 주소창에 입력한다.

### 2. 브라우저는 캐싱된 DNS 기록들을 통해 www.google.com에 대응되는 IP 주소가 있는지 확인한다.

`DNS(Domain Name System)` : URL들의 이름과 IP주소를 저장하고있는 데이터베이스

인터넷에 있는 모든 URL들은 고유의 IP주소가 지정되어있음

→ 이 IP주소를 통해 해당 웹사이트를 호스팅하고있는 서버 컴퓨터에 접근 가능

즉, `DNS` 는 전화번호부와 비슷한 역할을 하는데, 웹사이트의 이름들과 웹사이트에 접근하기 위해 필요한 IP주소를 저장하고있음

ex) 구글의 경우 구글을 사용하는 사용자가 매우 많기 때문에 구글의 서버 IP주소는 여러개

`**DNS`의 가장 큰 목적은 사람들에게 편리함을 주기 위함**

→ 숫자로 된 IP주소를 작성해도 원하는 웹사이트에 접속할 수 있지만, 매번 랜덤해보이는 숫자들을 검색하는 것은 매우 복잡한 일

→ 사람은 네이버, 다음, 구글처럼 이름을 외우는 것에 더 친숙하기때문

→ `DNS` 는 사람들이 웹사이트 주소에 쉽게 접속할 수 있게 매핑해주는 역할

### www.google.com을 검색하면 브라우저는 DNS기록을 4가지 캐시에서 확인

1. **브라우저 캐시**
  - 브라우저는 일정기간동안(유저가 이전에 설정한)의 `DNS` 기록들을 저장하고있음
  - `DNS query`가 이 곳에서 가장 먼저 실행
2. **OS 캐시**
  - 브라우저 캐시에 웹사이트 이름의 IP주소가 발견되지 않았다면, 브라우저는 `systemcall`을 통해서 OS가 저장하고 있는 `DNS` 기록들의 캐시에 접근
3. **router 캐시**
  - 컴퓨터에 `DNS` 기록을 찾지 못하면 브라우저는 `DNS`기록을 캐싱 하고 있는 `router`와 통신해서 찾으려고 함
4. **ISP 캐시**
  - 마지막으로 ISP 캐시 확인
  - ISP는 `DNS`서버를 구축하고있고 브라우저가 마지막으로 `DNS`기록이 있기를 바라며 접근

### 3. 요청한 URL이 캐시에 없으면, ISP의 DNS서버가 www.google.com을 호스팅하고 있는 서버의 IP주소를 찾기 위해 DNS query를 날린다.

[www.google.com](http://www.google.com) 에 접속하기 위해서는 IP주소를 반드시 알아야 함

`DNS query` 의 목적은 여러 다른 `DNS` 서버들을 검색해서 해당 사이트의 IP주소를 찾는 것

이러한 검색 ⇒ `recursive search`

IP주소를 찾을때까지 `DNS` 서버에서 다른 `DNS` 서버를 오가면서 반복적으로 검색하던지 찾지 못해 에러가 발생할 때까지 검색을 진행

이 상황에서, `ISP`의 `DNS` 서버를 `DNS recursor` 라고 부르고 인터넷을 통해 다른 `DNS` 서버들에게 물어 도메인 이름의 올바른 IP주소를 찾는데 책임을 갖고 있음

다른 `DNS` 서버들은 `name server`라고 불림 (웹사이트 도메인 이름의 구조에 기반하여 검색하기 때문)

도메인 이름 구조에 기반해서 검색한다고 하면 이해하기 어려워보이지만 원리는 매우 간단

[도메인 이름들의 구조 사진]


우리가 마주하는 웹사이트 URL들은 `third-level domain` , `second-level domain` , `top-level domain` 을 가지고 있음, 각 레벨별로 자신들만의 `name` 서버가 있고 여기서 `DNS look up` 프로세스 중에 쿼리가 진행됨

[www.google.com](http://www.google.com) 를 검색하면 먼저 `DNS recursor` 가 `root name server`에 연락

`root name` 서버는 `.com` 도메인 `name server`로 리다이렉트

`.com` `name server` 는 `[google.com](http://google.com)` `name server` 로 리다이렉트

`[google.com](http://google.com)` `name server` 는 `DNS` 기록에서 www.google.com에 매칭되는 IP주소를 찾아 `DNS recursor`로 보냄

⇒ 이 모든 요청들은 작은 데이터 패킷들을 통해 보내짐

패킷 안에는 보내는 요청의 내용과 `DNS recursor` 의 IP주소가 포함되어있음

이 패킷들은 원하는 `DNS` 기록을 가진 `DNS` 서버에 도달할 때까지 클라이언트와 서버를 여러번 오감

패킷들이 움직이는 것도 `routing table` 에 기반

`routing table` 을 통해 어떤 길로 가야 가장 빠른지 확인 가능

만약 패킷이 도중에 `loss` 되면 `request fail error` 가 발생

### 4. 브라우저가 서버와 TCP 연결한다.

브라우저가 올바른 IP주소를 받게되면 서버와 `Connection` 을 빌드

브라우저는 인터넷 프로토콜을 사용하여 서버와 연결됨

웹사이트의 HTTP 요청의 경우 **일반적으로 `TCP` 사용**

클라이언트와 서버간 데이터 패킷들이 오가려면 `TCP Connection` 이 되어야 함

`TCP/IP 3-way-handshake` 라는 프로세스를 통해 클라이언트와 서버 간의 `connection`

1. 클라이언트 머신이 `SYN 패킷`을 서버에 보내고 `connection`을 열어달라고 요청
2. 서버가 새로운 `connection`을 시작할 수 있는 포트가 있다면 `SYN/ACK 패킷`으로 수락
3. 클라이언트는 `SYN/ACK 패킷`을 서버로부터 받으면 서버에게 `ACK 패킷` 전송

이 과정이 끝나면 `TCP connection`이 완성되는 것이다.

### 5. 브라우저가 웹서버에 HTTP 요청한다.

`TCP` 로 연결되었다면, 데이터 전송

클라이언트의 브라우저는 `GET` 요청을 통해 서버에게 [www.google.com](http://www.google.com) 웹 페이지를 요구

경우에 따라 `POST` 요청을 사용할 수 있음

- browser identification(User-Agent 헤더)
- 받아들일 요청의 종류(Accept 헤더)
- 추갖거인 요청을 위해 TCP connection을 유지를 요청하는 connection 헤더
- 브라우저에서 얻은 쿠키 정보
- 기타 등등

### 6. 서버가 요청을 처리하고 response를 생성한다.

서버는 웹서버를 가지고 있음

이들은 브라우저로부터 요청받고 `request handler` 에게 요청을 전달해서 요청을 읽고 response를 생성

`Request handler` 는 ASP.NET, PHP, Ruby 등으로 작성된 프로그램 의미

이 `Request handler` 는 요청과 요청의 헤더, 쿠키를 읽어 요청이 무엇인지 파악하고 필요하다면 서버에 정보 업데이트

response를 특정 포맷(JSON, XML, HTML)으로 작성

### 7. 서버가 HTTP response를 보낸다.

서버의 response에는 요청한 웹페이지, status code, compression type(Content-Encoding) - 어떻게 인코딩 되어 있는지, 어떻게 페이지를 캐싱할지(Cache-Control), 설정할 쿠키가 있다면 쿠키, 개인정보 등이 포함된다.

샘플 HTTP 서버 response는 다음과 같다.


response의 첫줄은 `status code`를 나타낸다. 
`Status code`란 현재 response의 상태를 의미하고 총 5가지의 종류가 있다:

- 1xx은 정보만 담긴 메세지라는 것을 의미
- 2xx response가 성공적이라는 것을 의미
- 3xx 클라이언트를 다른 URL로 리다이렉트함을 의미
- 4xx 클라이언트 측에서 에러가 발생했음을 의미
- 5xx 서버 측에서 에러가 발생했음을 의미

### 8. 브라우저가 HTML Content를 보여준다.

브라우저는 HTML content를 단계적으로 보여준다.

처음에는 HTML의 스켈레톤(기본 틀)을 렌더링한다.

그 다음에는 `HTML tag`들을 체크하고 나서 추가적으로 필요한 웹페이지 요소들을(이미지, CSS 스타일시트, Javascript 파일, 등) GET으로 요청한다.

이 정적인 파일들은 브라우저에 의해 캐싱이 되서 나중에 해당 페이지를 방문할 때 다시 서버로부터 불러와지지 않도록 한다.

그 다음 www.google.com의 모습이 보이게 된다.

www.google.com을 검색하고 웹페이지가 뜰 때까지 엄청 많은 일들이 일어나지만, 이 모든 일들이 1초도 되지 않아서 완료가 된다.